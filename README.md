# react
- @soy22(정소영)

## ch02
### 2.4.1-1
- 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다. 요소 여러 개가 부모 요소 하나에 의하여 감싸져 있지 않기 때문에 오류가 발생했습니다.
### 2.4.1-2
- 리액트 컴포넌트에서 요소 여러 개를 하나의 요소로 감싸 주어 오류를 해결합니다.
### 2.4.1-3
- 여기서 꼭 div 요소를 사용하고 싶지 않을 수도 있습니다. 그런 경우에는 리액트 v16 이상 부터 도입된 Fragment라는 기능을 사용하면 됩니다.
### 2.4.1-4
- Fragment는 다음과 같은 형태로도 표현할 수 있습니다.
### 2.4.2
- JSX 안에서는 자바스크립트 표현식을 쓸 수 있습니다. 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됩니다. 자바스크립트 값을 JSX 안에서 한번 렌더링해 봅시다.
### 2.4.3
- 다른 내용을 렌더링해야 할 때는 JSX 밖에서 if 문을 사용하여 사전에 값을 설정하거나, { } 안에 조건부 연산자를 사용하면 됩니다. 조건부 연산자의 또 다른 이름은 삼항 연산자입니다.
### 2.4.4-1
- null을 렌더링하면 아무것도 보여 주지 않습니다.
### 2.4.4-2
- 더 짧은 코드로 똑같은 작업을 할 수 있습니다. && 연산자를 사용해서 조건부 렌더링을 할 수 있습니다.
### 2.4.5-1
- 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하면 오류가 발생합니다.
### 2.4.5-2
- name 값이 undefined일 때 보여 주고 싶은 문구가 있다면 다음과 같이 코드를 작성하면 됩니다.
### 2.4.6-1
- 리액트에서 DOM 요소에 스타일을 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어 주어야 합니다.
### 2.4.6-2
- 미리 선언하지 않고 바로 style 값을 지정하고 싶다면 다음과 같이 작성하면 됩니다.
### 2.4.7-1
- class 대신 className: src 디렉터리 안에 있는 App.css를 열어서 새 CSS 클래스를 작성
### 2.4.7-2
- App.js 파일에서 상단에 App.css를 불러온 뒤 div 요소에 className 값을 지정
### 2.4.8-1
- input 태그를 닫지 않았을 때 발생하는 오류
### 2.4.8-2
- input 태그를 닫아 오류 해결
### 2.4.8-3
- 태그 사이에 별도의 내용이 들어가지 않는 경우에는 다음과 같이 작성할 수도 있습니다. 이러한 태그를 self-closing 태그라고 부릅니다. 태그를 선언하면서 동시에 닫을 수 있는 태그죠.
### 2.4.9
- 일반 자바스크립트에서 주석을 작성할 때처럼 아무 데나 주석을 작성하면 그 주석은 페이지에 고스란히 나타납니다.
### 2.5.2-1
- 들여쓰기가 제대로 되어 있지 않은 코드
### 2.5.2-2
- 현재 열려 있는 프로젝트의 루트 디렉터리(src, public 디렉터리들이 위치한 곳)에서 .prettierrc라는 파일 생성

## ch03
### 3.1-1
- 2장에서 보았던 App 컴포넌트 - 함수형 컴포넌트
### 3.1-2
- 클래스형 컴포넌트
### 3.2.2
- MyComponent.js 파일을 열고 새 컴포넌트의 코드를 작성(함수형)
### 3.2.3.2
- 모듈 불러오기(import)
### 3.3.2
- App 컴포넌트에서 MyComponent의 props 값을 지정
### 3.3.3
- props 값을 따로 지정하지 않았을 때 보여 줄 기본값을 설정하는 defaultProps
### 3.3.4-1
- 컴포넌트 태그 사이의 내용을 보여 주는 props-children
### 3.3.4-2
- MyComponent 태그 사이에 작성한 리액트라는 문자열을 MyComponent 내부에서 보여 주려면 props.children 값을 보여 주어야 합니다.
### 3.3.5-1
- 작업을 더 편하게 하기 위해 ES6의 비구조화 할당 문법을 사용하여 내부 값을 바로 추출하는 방법. 이렇게 코드를 작성하면 name 값과 children 값을 더 짧은 코드로 사용할 수 있습니다.
### 3.3.5-2
- 함수의 파라미터가 객체라면 그 값을 바로 비구조화해서 사용하는 것이죠. 앞으로 함수형 컴포넌트에서 props를 사용할 때 이렇게 파라미터 부분에서 비구조화 할당 문법을 사용합니다.
### 3.3.6-1
- 컴포넌트의 propTypes를 지정
### 3.3.6-2
- PropTypes를 불러온 후 MyComponent.js 수정. name 값은 무조건 문자열(string) 형태로 전달해야 된다는 것을 의미.
### 3.3.6-3
- App 컴포넌트에서 name 값을 문자열이 아닌 숫자로 전달하면 오류.
### 3.3.6-4
- name 값을 제대로 설정해 주어 오류 해결
### 3.3.6.1-1
- isRequired를 사용하여 필수 propTypes 설정: 아직 favoriteNumber를 설정하지 않았기 때문에 오류
### 3.3.6.1-2
- isRequired를 사용하여 필수 propTypes 설정: MyComponent에게 favoriteNumber 값을 제대로 전달하여 오류 해결
### 3.3.7-1
- 클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 this.props를 조회하면 됩니다. MyComponent를 다음과 같이 클래스형 컴포넌트로 변환.
### 3.3.7-2
- 클래스형 컴포넌트에서 defaultProps와 propTypes를 설정할 때 class 내부에서 지정하는 방법도 있습니다.
### 3.4.1-1
- 클래스형 컴포넌트의 state: Counter.js 파일을 src 디렉터리에 생성
### 3.4.1-2
- 클래스형 컴포넌트의 state: Counter 컴포넌트를 App에서 불러와 렌더링
### 3.4.1.1
- state 객체 안에 여러 값이 있을 때
### 3.4.1.2
- state를 constructor에서 꺼내기
### 3.4.1.3-1
- this.setState에 객체 대신 함수 인자 전달하기: this.setState를 두 번 사용하는 것임에도 불구하고 버튼을 클릭할 때 숫자가 1씩 더해집니다. this.setState를 사용한다고 해서 state 값이 바로 바뀌지는 않기 때문입니다.
### 3.4.1.3-2
- this.setState에 객체 대신 함수 인자 전달하기: onClick에서 두 번째로 this.setState 함수를 사용할 때는 화살표 함수에서 바로 객체를 반환하도록 했기 때문에 숫자가 2씩 올라갑니다.
### 3.4.1.4
- setState를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때는 setState의 두 번째 파라미터로 콜백(callback) 함수를 등록하여 작업을 처리할 수 있습니다.
### 3.4.2.2-1
- 새 컴포넌트를 만들어서 useState를 사용해 보겠습니다. src 디렉터리에 Say.js라는 파일을 생성.
### 3.4.2.2-2
- Say 컴포넌트를 App에서 렌더링
### 3.4.2.3
- 한 컴포넌트에서 useState 여러 번 사용하기

## ch04
### 4.2.1.1
- 새 클래스형 컴포넌트 작성. src 디렉터리 내부에 EventPractice.js 파일 만들기.
### 4.2.1.2
- App.js에서 EventPractice 렌더링
### 4.2.2.1-1
- EventPractice 컴포넌트에 input 요소를 렌더링하는 코드와 해당 요소에 onChange 이벤트를 설정하는 코드를 작성
### 4.2.2.1-2
- 비동기적으로 이벤트 객체를 참조할 일이 있다면 e.persist() 함수를 호출해 주어야 합니다. 예를 들어 onChange 이벤트가 발생할 때, 앞으로 변할 인풋 값인 e.target.value를 콘솔에 기록해 보겠습니다.
### 4.2.2.2
- state에 input 값 담기
### 4.2.2.3
- 버튼을 누를 때 comment 값을 공백으로 설정
### 4.2.3.1
- 앞서 onChange와 onClick에 전달한 함수를 따로 빼내서 컴포넌트 임의 메서드를 만들어 보겠습니다.-기본 방식
### 4.2.3.2
- Property Initializer Syntax를 사용한 메서드 작성
### 4.2.4
- input 여러 개 다루기 
### 4.2.5
- onKeyPress 이벤트 핸들링: 키를 눌렀을 때 발생하는 KeyPress 이벤트를 처리하는 방법
### 4.3-1
- 위의 작업들을 함수형 컴포넌트로 구현해 보기
### 4.3-2
- 이번에는 useState를 통해 사용하는 상태에 문자열이 아닌 객체를 넣어 보겠습니다.

## ch05
### 5.1.1-1
- src 디렉터리 안에 ValidationSample.css 파일을 만듭니다.
### 5.1.1-2
- src 디렉터리 안에 ValidationSample.js 파일을 만듭니다.
### 5.1.2
- App 컴포넌트에서 ValidationSample 컴포넌트를 불러와 렌더링해 보겠습니다. 그 과정에서, App 컴포넌트를 함수형 컴포넌트에서 클래스형 컴포넌트로 전환해 줍니다.
### 5.2.2
- createRef를 통한 ref 설정
### 5.2.3.1
- input에 ref 달기
### 5.2.3.2
- 버튼 onClick 이벤트 코드 수정
### 5.3.2.1
- 컴포넌트 파일 ScrollBox.js 생성
### 5.3.2.2
- App 컴포넌트에서 스크롤 박스 컴포넌트 렌더링
### 5.3.3
- 컴포넌트에 메서드 생성
### 5.3.4
- 컴포넌트에 ref 달고 내부 메서드 사용

## ch06
### 6
- 웹 애플리케이션을 만들다 보면 다음과 같이 반복되는 코드를 작성할 때가 있습니다. src 디렉터리에 IterationSample.js라는 파일을 작성합니다.
### 6.2.1
- IterationSample 컴포넌트를 수정합니다. 문자열로 구성된 배열을 선언합니다. 그 배열 값을 사용하여 <li>…</li> JSX 코드로 된 배열을 새로 생성한 후 nameList에 담습니다.
### 6.2.2
- IterationSample 컴포넌트를 불러와 렌더링
### 6.3.1
- key 설정
### 6.4.1
- IterationSample 컴포넌트에서 useState를 사용하여 상태를 설정
### 6.4.2-1
- 새로운 이름을 등록할 수 있는 기능을 구현. ul 태그의 상단에 input과 button을 렌더링하고, input의 상태를 관리.
### 6.4.2-2
- 버튼을 클릭했을 때 호출할 onClick 함수를 선언하여 버튼의 onClick 이벤트로 설정. onClick 함수에서는 배열의 내장 함수 concat을 사용하여 새로운 항목을 추가한 배열을 만들고, setNames를 통해 상태를 업데이트.
### 6.4.3
- 데이터 제거 기능 구현하기.

## ch07
### 7.3.1
- src 디렉터리에 LifeCycleSample.js라는 컴포넌트를 만듭니다.
### 7.3.2
- App 컴포넌트에서 예제 컴포넌트 사용
### 7.3.3-1
- 만든 LifeCycleSample 컴포넌트의 render 함수에서 의도적으로 에러를 발생시켜본다.
### 7.3.3-2
- 에러를 잡아 주는 ErrorBoundary라는 컴포넌트를 생성
### 7.3.3-3
- 이 컴포넌트를 사용해 App.js에서 LifeCycleSample 컴포넌트를 감싸 줍니다.

## ch08
### 8.1-1
- useState 기능을 사용해서 숫자 카운터를 구현
### 8.1-2
- App 컴포넌트를 열어서 기존에 보여 주던 내용을 다 지우고 Counter 컴포넌트를 렌더링
### 8.1.1-1
- useState를 여러 번 사용하기
### 8.1.1-2
- App 컴포넌트에서 이 컴포넌트를 렌더링
### 8.2
- 전에 만들었던 Info 컴포넌트에 useEffect를 적용
### 8.2.1
- useEffect에서 설정한 함수를 컴포넌트가 화면에 맨 처음 렌더링될 때만 실행하고, 업데이트될 때는 실행하지 않으려면 함수의 두 번째 파라미터로 비어 있는 배열을 넣어 주면 된다.
### 8.2.2
- 특정 값이 업데이트될 때만 실행하고 싶을 때
### 8.2.3-1
- 컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리(cleanup) 함수를 반환해 주어야 한다.
### 8.2.3-2
- 오직 언마운트될 때만 뒷정리 함수를 호출하고 싶다면 useEffect 함수의 두 번째 파라미터에 비어 있는 배열을 넣으면 된다.
### 8.3.1-1
- (카운터 구현하기) 먼저 useReducer를 사용하여 기존의 Counter 컴포넌트를 다시 구현
### 8.3.1-2
- App에서 Counter를 다시 렌더링
### 8.3.2-1
- seReducer를 사용하여 Info 컴포넌트에서 인풋 상태를 관리
### 8.3.2-2
- App에서 Info 컴포넌트를 렌더링
### 8.4-1
- useMemo를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다.
### 8.4-2
- App에서 컴포넌트를 렌더링
### 8.4-3
- list 배열의 내용이 바뀔 때만 getAverage 함수가 호출된다.
### 8.5
- useCallback을 사용하여 최적화
### 8.6
- useRef Hook은 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 준다.
### 8.7-1
- 커스텀 Hooks 만들기
### 8.7-2
- 이 Hook을 Info 컴포넌트에서 사용

## ch09
### 9.1-1
- styling-react 프로젝트 만든 후 App.js 수정
### 9.1-2
- styling-react 프로젝트 만든 후 App.css 수정
### 9.1.2-1
- CSS Selector를 사용하면 CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용할 수 있다.
### 9.1.2-2
- 이에 맞춰 컴포넌트의 JSX 부분 수정
### 9.2-1
- scr 디렉터리에 SassComponent.scss 파일 작성
### 9.2-2
- 이 Sass 스타일시트를 사용하는 SassComponent.js 컴포넌트 파일도 src에 만든다.
### 9.2-3
- 이 컴포넌트를 App 컴포넌트에서 보여 준다.
### 9.2.1-1
- 여러 파일에서 사용될 수 있는 Sass 변수 및 믹스인은 다른 파일로 따로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러와 사용할 수 있다. src 디렉터리에 styles라는 디렉터리를 생성하고, 그 안에 utils.scss 파일을 만든다.
### 9.2.1-2
- utils.scss 파일에서 선언한 변수와 믹스인을 SassComponent.scss에서 사용한다. 다른 scss 파일을 불러올 때는 @import 구문을 사용한다.
### 9.2.2-1
- sassRegex 찾기
### 9.2.2-2
- use:에 있는 ‘sass-loader’ 부분을 지우고, 뒷부분에 concat을 통해 커스터마이징된 sass-loader 설정을 넣어 준다.
### 9.2.2-3
- webpack.config.js를 열어서 조금 전 수정했던 sass-loader의 옵션에 있는 data 필드를 수정
### 9.2.3-1
- utils.scss 파일을 열고 물결 표시를 사용하여 라이브러리를 불러온 다음 두 줄을 코드 상단에 넣어 준다.
### 9.2.3-2
- include-media와 open-color를 SassComponent.scss에서 사용한다.
### 9.3-1
- CSSModule.module.css라는 파일을 src 디렉터리에 생성
### 9.3-2
- CSS Module을 사용하는 리액트 컴포넌트도 작성
### 9.3-3
- CSSModule 관련 컴포넌트와 스타일을 모두 작성했다면 App 컴포넌트에서 렌더링
### 9.3-4
- CSS Module을 사용한 클래스 이름을 두 개 이상 적용할 때는 다음과 같이 코드를 작성
### 9.3-5
- CSS Module을 사용한 클래스 이름을 두 개 이상 적용할 때는 다음과 같이 코드를 작성
### 9.3.2-1
- Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해 주면 CSS Module로 사용할 수 있다.
### 9.3.2-2
- 그러고 나서 CSSModule.js 상단에서도 .css 파일 대신 .scss 파일을 불러온다.
### 9.4-1
- src 디렉터리에 StyledComponent.js 파일을 생성한 뒤 예제 코드를 작성
### 9.4-2
- 이 컴포넌트를 App 컴포넌트에서 보여준다.
### 9.4.5
- 브라우저의 가로 크기에 따라 다른 스타일을 적용하기 위해서는 일반 CSS를 사용할 때와 똑같이 media 쿼리(query)를 사용하면 된다.

## ch10
### 10.1.2
- 코드를 작성할 때 코드 스타일을 깔끔하게 정리하기 위해 프로젝트의 최상위 디렉터리에 .prettierrc 파일을 생성
### 10.1.3
- index.css에서 background 속성 설정
### 10.1.4
- App 컴포넌트 초기화
### 10.2.1-1
- TodoTemplate 만들기: src 디렉터리에 components 디렉터리를 생성한 뒤 그 안에 TodoTemplate.js 파일을 생성
### 10.2.1-2
- 이 컴포넌트를 App.js에서 불러와 렌더링
### 10.2.1-3
- jsconfig.json 수정
### 10.2.1-4
- 스타일을 작성
### 10.2.2-1
- TodoInsert 만들기: components 디렉터리에 TodoInsert.js 파일 생성
### 10.2.2-2
- 이 컴포넌트를 App에서 불러와 렌더링
### 10.2.2-3
- 이 컴포넌트를 스타일링
### 10.2.3-1
- components 디렉터리에 TodoListItem.js 파일 생성 후 작성
### 10.2.3-2
- TodoList.js 컴포넌트를 생성 후 작성
### 10.2.3-3
- App에서 렌더링
### 10.2.3-4
- TodoList 스타일링
### 10.2.3-5
- TodoListItem 스타일링
### 10.3.1-1
- App에서 useState를 사용하여 todos라는 상태를 정의하고, todos를 TodoList의 props로 전달
### 10.3.1-2
- 값을 받아온 후 TodoItem으로 변환하여 렌더링
### 10.3.1-3
- TodoListItem 컴포넌트에서 받아 온 todo 값에 따라 제대로 된 UI를 보여 줄 수 있도록 컴포넌트를 수정. 조건부 스타일링을 위해 classnames를 사용.
### 10.3.2.1
- TodoInsert value 상태 관리하기
### 10.3.2.3todos 배열에 새 객체 추가하기
- 리액트 개발자 도구
### 10.3.2.4
- TodoInsert에서 onSubmit 이벤트 설정하기
### 10.3.3.2
- todos 배열에서 id로 항목 지우기
### 10.3.3.3-1
- TodoListItem에서 삭제 함수 호출하기
### 10.3.3.3-2
- 이제 삭제 버튼을 누르면 TodoListItem에서 onRemove 함수에 현재 자신이 가진 id를 넣어서 삭제 함수를 호출하도록 설정
### 10.3.4.1
-  onToggle 구현하기
### 10.3.4.2-1
- TodoListItem에서 토글 함수 호출하기
### 10.3.4.2-2
- TodoListItem도 수정해 보세요. 이전에 onRemove를 사용했던 것과 비슷하게 구현

## ch11
### 11.1
- 많은 데이터 렌더링하기
### 11.4
- React.memo를 사용하여 컴포넌트 성능 최적화
### 11.5.1
- useState의 함수형 업데이트
### 11.5.2
- useReducer 사용하기
### 11.7
- TodoList 컴포넌트 최적화하기
### 11.8.2
- TodoList 수정. List 컴포넌트를 사용할 때는 해당 리스트의 전체 크기와 각 항목의 높이, 각 항목을 렌더링할 때 사용해야 하는 함수, 그리고 배열을 props로 넣어 주어야 한다. 그러면 이 컴포넌트가 전달받은 props를 사용하여 자동으로 최적화해준다.
### 11.8.3-1
- TodoList를 저장하고 나면 스타일이 깨져서 나타날 텐데 TodoListItem 컴포넌트를 다음과 같이 수정하면 해결된다.
### 11.8.3-2
- TodoListItem의 스타일 파일에서 최하단에 있던 & + &를 사용하여 .TodoListItem 사이사이에 테두리를 설정했던 코드와 &:nth-child(even)을 사용하여 다른 배경 색상을 주는 코드를 지우고, 코드 최상단에 다음 코드를 삽입.

## ch12
### 12.1.2 
- immer를 사용하지 않고 불변성 유지
### 12.1.4 
- App 컴포넌트에 immer 적용하기
### 12.1.5 
- useState의 함수형 업데이트와 immer 함께 쓰기

## ch13
### 13.2.2
- 프로젝트에 리액트 라우터를 적용할 때는 src/index.js 파일에서 react-router-dom에 내장되어 있는 BrowserRouter라는 컴포넌트를 사용하여 감싸면 된다.
### 13.2.3-1
- 라우트로 사용할 페이지 컴포넌트를 만든다. src 디렉터리에 Home 컴포넌트를 만든다.
### 13.2.3-2
- 라우트로 사용할 페이지 컴포넌트를 만든다. src 디렉터리에 About 컴포넌트를 만든다.
### 13.2.4-1
- Route 컴포넌트로 특정 주소에 컴포넌트 연결
### 13.2.4-2
- Home을 위한 Route 컴포넌트를 사용할 때 exact라는 props를 true로 설정한다.
### 13.2.5
- Link 컴포넌트를 사용하여 다른 주소로 이동하기
### 13.3-1
- Route 하나에 여러 개의 path 설정하기
### 13.3-2
- 이렇게 Route를 두 번 사용하는 대신, path props를 배열로 설정해 주면 여러 경로에서 같은 컴포넌트를 보여 줄 수 있다.
### 13.4.1-1
- URL 파라미터
### 13.4.1-2
- App 컴포넌트에서 Profile 컴포넌트를 위한 라우트를 정의
### 13.4.2-1
- URL 쿼리
### 13.4.2-2
-  About 컴포넌트에서 location.search 값에 있는 detail이 true인지 아닌지에 따라 추가 정보를 보여 주도록 만든다. About 컴포넌트를 수정한다.
### 13.5-1
- 첫 번째 Route 컴포넌트에는 component 대신 render라는 props를 넣어 준다. 컴포넌트 자체를 전달하는 것이 아니라, 보여 주고 싶은 JSX를 넣어 줄 수 있다.
### 13.5-2
- 컴포넌트를 다 만들었다면 기존의 App 컴포넌트에 있던 프로필 링크를 지우고, Profiles 컴포넌트를 /profiles 경로에 연결시켜 준다. 그리고 해당 경로로 이동하는 링크도 추가한다.
### 13.6.1
- history 객체 사용
### 13.6.2-1
- withRouter 함수 사용
### 13.6.2-2
- Profiles 컴포넌트에 렌더링
### 13.6.2-3
- WithRouterSample 컴포넌트를 Profiles에서 지우고 Profile 컴포넌트에 넣으면 match 쪽에 URL 파라미터가 제대로 보인다.
### 13.6.3
- Switch 컴포넌트는 여러 Route를 감싸서 그중 일치하는 단 하나의 라우트만을 렌더링시켜 준다.
### 13.6.4
- Profiles에서 사용하고 있는 컴포넌트에서 Link 대신 NavLink를 사용하게 하고, 현재 선택되어 있는 경우 검정색 배경에 흰색 글씨로 스타일을 보여 주게끔 코드를 수정한다.
